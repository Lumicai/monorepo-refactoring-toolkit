{
  "Extract Interface": {
    "prefix": "extract-interface",
    "body": [
      "interface I${1:ComponentName} {",
      "  ${2:// Define interface properties and methods}",
      "  ${3:property}: ${4:string};",
      "  ${5:method}(${6:params}): ${7:ReturnType};",
      "}",
      "",
      "class ${1:ComponentName} implements I${1:ComponentName} {",
      "  ${3:property}: ${4:string};",
      "",
      "  ${5:method}(${6:params}): ${7:ReturnType} {",
      "    ${8:// Implementation}",
      "    ${0}",
      "  }",
      "}"
    ],
    "description": "Extract an interface from a class to improve code organization"
  },

  "Create Base Service": {
    "prefix": "base-service",
    "body": [
      "abstract class Base${1:Service} {",
      "  protected readonly baseUrl: string;",
      "  protected readonly httpClient: ${2:HttpClient};",
      "",
      "  constructor(baseUrl: string, httpClient: ${2:HttpClient}) {",
      "    this.baseUrl = baseUrl;",
      "    this.httpClient = httpClient;",
      "  }",
      "",
      "  protected async get<T>(endpoint: string): Promise<T> {",
      "    return this.httpClient.get<T>(`\\${this.baseUrl}/\\${endpoint}`);",
      "  }",
      "",
      "  protected async post<T>(endpoint: string, data: any): Promise<T> {",
      "    return this.httpClient.post<T>(`\\${this.baseUrl}/\\${endpoint}`, data);",
      "  }",
      "",
      "  protected async put<T>(endpoint: string, data: any): Promise<T> {",
      "    return this.httpClient.put<T>(`\\${this.baseUrl}/\\${endpoint}`, data);",
      "  }",
      "",
      "  protected async delete<T>(endpoint: string): Promise<T> {",
      "    return this.httpClient.delete<T>(`\\${this.baseUrl}/\\${endpoint}`);",
      "  }",
      "",
      "  // Abstract methods to be implemented by derived classes",
      "  abstract ${3:specificMethod}(): ${4:Promise<any>};",
      "}",
      "",
      "class ${5:Specific}${1:Service} extends Base${1:Service} {",
      "  constructor(httpClient: ${2:HttpClient}) {",
      "    super('${6:/api/endpoint}', httpClient);",
      "  }",
      "",
      "  async ${3:specificMethod}(): ${4:Promise<any>} {",
      "    ${7:// Specific implementation}",
      "    return this.get('${8:endpoint}');",
      "  }",
      "",
      "  ${0}",
      "}"
    ],
    "description": "Create a base service class for common CRUD operations"
  },

  "Extract Common Type": {
    "prefix": "extract-type",
    "body": [
      "// Common type definition",
      "export type ${1:CommonType} = {",
      "  ${2:id}: ${3:string};",
      "  ${4:name}: ${5:string};",
      "  ${6:// Add common properties}",
      "  ${7:property}: ${8:type};",
      "};",
      "",
      "// Extended types",
      "export type ${9:Extended}${1:CommonType} = ${1:CommonType} & {",
      "  ${10:// Additional properties}",
      "  ${11:additionalProperty}: ${12:type};",
      "};",
      "",
      "// Usage in components/services",
      "class ${13:Component} {",
      "  private data: ${1:CommonType}[] = [];",
      "",
      "  process${1:CommonType}(item: ${1:CommonType}): void {",
      "    ${14:// Process the common type}",
      "    ${0}",
      "  }",
      "}"
    ],
    "description": "Extract common type definitions to reduce duplication"
  },

  "Factory Pattern": {
    "prefix": "factory-pattern",
    "body": [
      "// Abstract base class",
      "abstract class ${1:Product} {",
      "  abstract ${2:operation}(): ${3:string};",
      "}",
      "",
      "// Concrete implementations",
      "class ${4:ConcreteProduct}A extends ${1:Product} {",
      "  ${2:operation}(): ${3:string} {",
      "    return '${5:Result from ConcreteProductA}';",
      "  }",
      "}",
      "",
      "class ${4:ConcreteProduct}B extends ${1:Product} {",
      "  ${2:operation}(): ${3:string} {",
      "    return '${6:Result from ConcreteProductB}';",
      "  }",
      "}",
      "",
      "// Factory",
      "class ${7:Factory} {",
      "  static create${1:Product}(type: '${8:A}' | '${9:B}'): ${1:Product} {",
      "    switch (type) {",
      "      case '${8:A}':",
      "        return new ${4:ConcreteProduct}A();",
      "      case '${9:B}':",
      "        return new ${4:ConcreteProduct}B();",
      "      default:",
      "        throw new Error(`Unknown ${1:Product} type: \\${type}`);",
      "    }",
      "  }",
      "}",
      "",
      "// Usage",
      "const product = ${7:Factory}.create${1:Product}('${8:A}');",
      "console.log(product.${2:operation}());",
      "${0}"
    ],
    "description": "Implement factory pattern to centralize object creation"
  },

  "Dependency Injection": {
    "prefix": "dependency-injection",
    "body": [
      "// Interface for dependency",
      "interface I${1:Dependency} {",
      "  ${2:method}(): ${3:ReturnType};",
      "}",
      "",
      "// Concrete implementation",
      "class ${4:Concrete}${1:Dependency} implements I${1:Dependency} {",
      "  ${2:method}(): ${3:ReturnType} {",
      "    ${5:// Implementation}",
      "    ${6:return 'result';}",
      "  }",
      "}",
      "",
      "// Consumer class with dependency injection",
      "class ${7:Consumer} {",
      "  constructor(private readonly ${8:dependency}: I${1:Dependency}) {}",
      "",
      "  public ${9:execute}(): ${10:void} {",
      "    const result = this.${8:dependency}.${2:method}();",
      "    ${11:// Use the result}",
      "    console.log(result);",
      "  }",
      "}",
      "",
      "// Usage with dependency injection",
      "const ${8:dependency} = new ${4:Concrete}${1:Dependency}();",
      "const ${12:consumer} = new ${7:Consumer}(${8:dependency});",
      "${12:consumer}.${9:execute}();",
      "${0}"
    ],
    "description": "Implement dependency injection pattern for better testability"
  },

  "Observer Pattern": {
    "prefix": "observer-pattern",
    "body": [
      "// Observer interface",
      "interface I${1:Observer} {",
      "  update(${2:data}: ${3:any}): void;",
      "}",
      "",
      "// Subject interface",
      "interface I${4:Subject} {",
      "  addObserver(observer: I${1:Observer}): void;",
      "  removeObserver(observer: I${1:Observer}): void;",
      "  notifyObservers(${2:data}: ${3:any}): void;",
      "}",
      "",
      "// Concrete Subject",
      "class ${5:ConcreteSubject} implements I${4:Subject} {",
      "  private observers: I${1:Observer}[] = [];",
      "",
      "  addObserver(observer: I${1:Observer}): void {",
      "    this.observers.push(observer);",
      "  }",
      "",
      "  removeObserver(observer: I${1:Observer}): void {",
      "    const index = this.observers.indexOf(observer);",
      "    if (index > -1) {",
      "      this.observers.splice(index, 1);",
      "    }",
      "  }",
      "",
      "  notifyObservers(${2:data}: ${3:any}): void {",
      "    this.observers.forEach(observer => observer.update(${2:data}));",
      "  }",
      "",
      "  ${6:businessMethod}(): void {",
      "    ${7:// Business logic}",
      "    const ${2:data} = ${8:'some data'};",
      "    this.notifyObservers(${2:data});",
      "  }",
      "}",
      "",
      "// Concrete Observer",
      "class ${9:ConcreteObserver} implements I${1:Observer} {",
      "  constructor(private name: string) {}",
      "",
      "  update(${2:data}: ${3:any}): void {",
      "    console.log(`\\${this.name} received update:`, ${2:data});",
      "  }",
      "}",
      "",
      "// Usage",
      "const subject = new ${5:ConcreteSubject}();",
      "const observer1 = new ${9:ConcreteObserver}('Observer1');",
      "const observer2 = new ${9:ConcreteObserver}('Observer2');",
      "",
      "subject.addObserver(observer1);",
      "subject.addObserver(observer2);",
      "subject.${6:businessMethod}();",
      "${0}"
    ],
    "description": "Implement observer pattern for event-driven architecture"
  },

  "Utility Helper": {
    "prefix": "utility-helper",
    "body": [
      "/**",
      " * ${1:Utility class description}",
      " */",
      "export class ${2:UtilityName} {",
      "  /**",
      "   * ${3:Method description}",
      "   * @param ${4:param} - ${5:Parameter description}",
      "   * @returns ${6:Return description}",
      "   */",
      "  static ${7:methodName}(${4:param}: ${8:ParamType}): ${9:ReturnType} {",
      "    ${10:// Validation}",
      "    if (!${4:param}) {",
      "      throw new Error('${11:Invalid parameter}');",
      "    }",
      "",
      "    ${12:// Implementation}",
      "    ${13:return param;}",
      "  }",
      "",
      "  /**",
      "   * ${14:Another method description}",
      "   */",
      "  static ${15:anotherMethod}(${16:params}): ${17:ReturnType} {",
      "    ${18:// Implementation}",
      "    ${0}",
      "  }",
      "",
      "  // Private helper methods",
      "  private static ${19:helperMethod}(${20:params}): ${21:ReturnType} {",
      "    ${22:// Helper implementation}",
      "  }",
      "}"
    ],
    "description": "Create utility helper class with static methods"
  },

  "Error Handling Wrapper": {
    "prefix": "error-wrapper",
    "body": [
      "/**",
      " * Custom error class for ${1:specific domain}",
      " */",
      "export class ${2:Custom}Error extends Error {",
      "  constructor(",
      "    message: string,",
      "    public readonly code: string,",
      "    public readonly statusCode?: number",
      "  ) {",
      "    super(message);",
      "    this.name = '${2:Custom}Error';",
      "  }",
      "}",
      "",
      "/**",
      " * Result wrapper for better error handling",
      " */",
      "export type Result<T, E = Error> = {",
      "  success: true;",
      "  data: T;",
      "} | {",
      "  success: false;",
      "  error: E;",
      "};",
      "",
      "/**",
      " * Safe async operation wrapper",
      " */",
      "export async function safeAsync<T>(",
      "  operation: () => Promise<T>",
      "): Promise<Result<T>> {",
      "  try {",
      "    const data = await operation();",
      "    return { success: true, data };",
      "  } catch (error) {",
      "    return { ",
      "      success: false, ",
      "      error: error instanceof Error ? error : new Error(String(error))",
      "    };",
      "  }",
      "}",
      "",
      "/**",
      " * Usage example",
      " */",
      "async function ${3:exampleUsage}() {",
      "  const result = await safeAsync(async () => {",
      "    ${4:// Your async operation}",
      "    return ${5:'success'};",
      "  });",
      "",
      "  if (result.success) {",
      "    console.log('Success:', result.data);",
      "  } else {",
      "    console.error('Error:', result.error.message);",
      "  }",
      "}",
      "${0}"
    ],
    "description": "Create error handling wrapper with Result type"
  },

  "Configuration Manager": {
    "prefix": "config-manager",
    "body": [
      "/**",
      " * Configuration interface",
      " */",
      "interface I${1:Config} {",
      "  ${2:apiUrl}: string;",
      "  ${3:timeout}: number;",
      "  ${4:retryAttempts}: number;",
      "  ${5:// Add more config properties}",
      "}",
      "",
      "/**",
      " * Configuration manager with validation",
      " */",
      "export class ${6:Config}Manager {",
      "  private static instance: ${6:Config}Manager;",
      "  private config: I${1:Config};",
      "",
      "  private constructor() {",
      "    this.config = this.loadConfig();",
      "    this.validateConfig();",
      "  }",
      "",
      "  static getInstance(): ${6:Config}Manager {",
      "    if (!${6:Config}Manager.instance) {",
      "      ${6:Config}Manager.instance = new ${6:Config}Manager();",
      "    }",
      "    return ${6:Config}Manager.instance;",
      "  }",
      "",
      "  private loadConfig(): I${1:Config} {",
      "    return {",
      "      ${2:apiUrl}: process.env.${7:API_URL} || '${8:http://localhost:3000}',",
      "      ${3:timeout}: parseInt(process.env.${9:TIMEOUT} || '${10:5000}'),",
      "      ${4:retryAttempts}: parseInt(process.env.${11:RETRY_ATTEMPTS} || '${12:3}'),",
      "      ${13:// Add more config loading}",
      "    };",
      "  }",
      "",
      "  private validateConfig(): void {",
      "    if (!this.config.${2:apiUrl}) {",
      "      throw new Error('${2:apiUrl} is required');",
      "    }",
      "    if (this.config.${3:timeout} <= 0) {",
      "      throw new Error('${3:timeout} must be positive');",
      "    }",
      "    ${14:// Add more validation}",
      "  }",
      "",
      "  get${1:Config}(): I${1:Config} {",
      "    return { ...this.config };",
      "  }",
      "",
      "  get(key: keyof I${1:Config}): I${1:Config}[keyof I${1:Config}] {",
      "    return this.config[key];",
      "  }",
      "}",
      "",
      "// Usage",
      "const configManager = ${6:Config}Manager.getInstance();",
      "const ${2:apiUrl} = configManager.get('${2:apiUrl}');",
      "${0}"
    ],
    "description": "Create configuration manager with singleton pattern"
  },

  "Async Queue Manager": {
    "prefix": "async-queue",
    "body": [
      "/**",
      " * Task interface for queue operations",
      " */",
      "interface Task<T> {",
      "  id: string;",
      "  operation: () => Promise<T>;",
      "  resolve: (value: T) => void;",
      "  reject: (error: Error) => void;",
      "}",
      "",
      "/**",
      " * Async queue manager for controlling concurrent operations",
      " */",
      "export class AsyncQueueManager {",
      "  private queue: Task<any>[] = [];",
      "  private running: number = 0;",
      "  private readonly maxConcurrent: number;",
      "",
      "  constructor(maxConcurrent: number = ${1:3}) {",
      "    this.maxConcurrent = maxConcurrent;",
      "  }",
      "",
      "  /**",
      "   * Add a task to the queue",
      "   */",
      "  async enqueue<T>(operation: () => Promise<T>, id?: string): Promise<T> {",
      "    return new Promise<T>((resolve, reject) => {",
      "      const task: Task<T> = {",
      "        id: id || Date.now().toString(),",
      "        operation,",
      "        resolve,",
      "        reject",
      "      };",
      "",
      "      this.queue.push(task);",
      "      this.processQueue();",
      "    });",
      "  }",
      "",
      "  /**",
      "   * Process the queue",
      "   */",
      "  private async processQueue(): Promise<void> {",
      "    if (this.running >= this.maxConcurrent || this.queue.length === 0) {",
      "      return;",
      "    }",
      "",
      "    const task = this.queue.shift()!;",
      "    this.running++;",
      "",
      "    try {",
      "      const result = await task.operation();",
      "      task.resolve(result);",
      "    } catch (error) {",
      "      task.reject(error instanceof Error ? error : new Error(String(error)));",
      "    } finally {",
      "      this.running--;",
      "      this.processQueue(); // Process next task",
      "    }",
      "  }",
      "",
      "  /**",
      "   * Get queue status",
      "   */",
      "  getStatus(): { queued: number; running: number; maxConcurrent: number } {",
      "    return {",
      "      queued: this.queue.length,",
      "      running: this.running,",
      "      maxConcurrent: this.maxConcurrent",
      "    };",
      "  }",
      "",
      "  /**",
      "   * Clear the queue",
      "   */",
      "  clear(): void {",
      "    this.queue.forEach(task => {",
      "      task.reject(new Error('Queue cleared'));",
      "    });",
      "    this.queue = [];",
      "  }",
      "}",
      "",
      "// Usage example",
      "const queueManager = new AsyncQueueManager(${2:5});",
      "",
      "async function ${3:example}() {",
      "  try {",
      "    const result = await queueManager.enqueue(async () => {",
      "      ${4:// Your async operation}",
      "      return ${5:'result'};",
      "    });",
      "    console.log('Result:', result);",
      "  } catch (error) {",
      "    console.error('Error:', error);",
      "  }",
      "}",
      "${0}"
    ],
    "description": "Create async queue manager for controlling concurrent operations"
  },

  "Consolidation Helper": {
    "prefix": "consolidate-duplicates",
    "body": [
      "/**",
      " * Consolidation helper for removing duplicate code",
      " */",
      "export class ConsolidationHelper {",
      "  /**",
      "   * Extract common functionality into shared utility",
      "   */",
      "  static extractCommon${1:Functionality}(",
      "    ${2:items}: ${3:ItemType}[]",
      "  ): ${4:CommonResult} {",
      "    // Extract common properties/logic",
      "    const common${5:Properties} = ${2:items}.reduce((acc, item) => {",
      "      ${6:// Logic to find common elements}",
      "      return acc;",
      "    }, {} as ${7:CommonType});",
      "",
      "    return {",
      "      common: common${5:Properties},",
      "      ${8:// Additional extracted data}",
      "    };",
      "  }",
      "",
      "  /**",
      "   * Merge duplicate implementations",
      "   */",
      "  static mergeDuplicates<T extends { ${9:id}: string }>(",
      "    duplicates: T[]",
      "  ): T {",
      "    if (duplicates.length === 0) {",
      "      throw new Error('No duplicates to merge');",
      "    }",
      "",
      "    // Use first item as base",
      "    const merged = { ...duplicates[0] };",
      "",
      "    // Merge properties from other duplicates",
      "    for (let i = 1; i < duplicates.length; i++) {",
      "      const duplicate = duplicates[i];",
      "      ${10:// Custom merge logic}",
      "      Object.assign(merged, duplicate);",
      "    }",
      "",
      "    return merged;",
      "  }",
      "",
      "  /**",
      "   * Generate consolidated interface from multiple classes",
      "   */",
      "  static generateConsolidatedInterface(",
      "    classes: string[]",
      "  ): string {",
      "    return `",
      "interface I${11:Consolidated} {",
      "  ${12:// Common interface definition}",
      "  ${13:commonMethod}(): ${14:ReturnType};",
      "}",
      "",
      "class ${15:Consolidated}Implementation implements I${11:Consolidated} {",
      "  ${13:commonMethod}(): ${14:ReturnType} {",
      "    ${16:// Consolidated implementation}",
      "    ${0}",
      "  }",
      "}",
      "    `.trim();",
      "  }",
      "}"
    ],
    "description": "Helper functions for consolidating duplicate code patterns"
  }
}