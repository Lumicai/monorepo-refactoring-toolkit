name: Deploy to Environments

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment"
        required: true
        type: choice
        options:
          - development
          - staging
          - production
        default: staging
      version:
        description: "Version to deploy (leave empty for latest)"
        required: false
        type: string
      skip_health_check:
        description: "Skip health check after deployment"
        type: boolean
        default: false
      rollback:
        description: "Rollback to previous version"
        type: boolean
        default: false

concurrency:
  group: deploy-${{ github.event.inputs.environment || 'production' }}
  cancel-in-progress: false

env:
  NODE_VERSION: "20"
  PNPM_VERSION: "8.15.0"

jobs:
  prepare-deployment:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.config.outputs.environment }}
      version: ${{ steps.config.outputs.version }}
      deploy-url: ${{ steps.config.outputs.deploy-url }}
      is-production: ${{ steps.config.outputs.is-production }}
      rollback: ${{ steps.config.outputs.rollback }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure deployment
        id: config
        run: |
          # Determine environment
          if [[ "${{ github.event_name }}" == "release" ]]; then
            ENVIRONMENT="production"
          else
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          fi

          # Determine version
          if [[ "${{ github.event.inputs.version }}" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [[ "${{ github.event_name }}" == "release" ]]; then
            VERSION="${{ github.event.release.tag_name }}"
          else
            VERSION="latest"
          fi

          # Configure environment-specific settings
          case "$ENVIRONMENT" in
            "development")
              DEPLOY_URL="https://dev.wundr.adaptic.ai"
              ;;
            "staging")
              DEPLOY_URL="https://staging.wundr.adaptic.ai"
              ;;
            "production")
              DEPLOY_URL="https://wundr.adaptic.ai"
              ;;
          esac

          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "deploy-url=$DEPLOY_URL" >> $GITHUB_OUTPUT
          echo "is-production=$([ "$ENVIRONMENT" = "production" ] && echo "true" || echo "false")" >> $GITHUB_OUTPUT
          echo "rollback=${{ github.event.inputs.rollback || 'false' }}" >> $GITHUB_OUTPUT

          echo "Deployment configuration:"
          echo "  Environment: $ENVIRONMENT"
          echo "  Version: $VERSION"
          echo "  URL: $DEPLOY_URL"
          echo "  Is Production: $([ "$ENVIRONMENT" = "production" ] && echo "true" || echo "false")"

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: prepare-deployment
    if: needs.prepare-deployment.outputs.is-production == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: "ghcr.io/${{ github.repository }}:${{ needs.prepare-deployment.outputs.version }}"
          format: "sarif"
          output: "trivy-results.sarif"

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: "trivy-results.sarif"

      - name: Fail on critical vulnerabilities
        run: |
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            -v ${{ github.workspace }}:/workspace \
            aquasec/trivy image \
            --exit-code 1 \
            --severity CRITICAL \
            ghcr.io/${{ github.repository }}:${{ needs.prepare-deployment.outputs.version }}

  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [prepare-deployment, security-scan]
    if: always() && (needs.security-scan.result == 'success' || needs.prepare-deployment.outputs.is-production == 'false')
    environment:
      name: ${{ needs.prepare-deployment.outputs.environment }}
      url: ${{ needs.prepare-deployment.outputs.deploy-url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        if: secrets.AWS_ACCESS_KEY_ID
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}

      - name: Deploy to AWS ECS
        if: secrets.AWS_ACCESS_KEY_ID
        run: |
          ENVIRONMENT="${{ needs.prepare-deployment.outputs.environment }}"
          VERSION="${{ needs.prepare-deployment.outputs.version }}"

          # Update ECS service
          aws ecs update-service \
            --cluster "wundr-$ENVIRONMENT" \
            --service "wundr-$ENVIRONMENT" \
            --force-new-deployment \
            --task-definition "wundr-$ENVIRONMENT:latest"

          # Wait for deployment to complete
          aws ecs wait services-stable \
            --cluster "wundr-$ENVIRONMENT" \
            --services "wundr-$ENVIRONMENT"

      - name: Deploy to Vercel
        if: secrets.VERCEL_TOKEN
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: "--prod"
          alias-domains: ${{ needs.prepare-deployment.outputs.deploy-url }}

      - name: Deploy to Railway
        if: secrets.RAILWAY_TOKEN
        run: |
          npm install -g @railway/cli
          railway login --token ${{ secrets.RAILWAY_TOKEN }}
          railway up --service wundr-${{ needs.prepare-deployment.outputs.environment }}

      - name: Deploy to Kubernetes
        if: secrets.KUBE_CONFIG
        run: |
          ENVIRONMENT="${{ needs.prepare-deployment.outputs.environment }}"
          VERSION="${{ needs.prepare-deployment.outputs.version }}"

          # Create kubeconfig
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

          # Apply deployment
          envsubst < k8s/deployment.yaml | kubectl apply -f -

          # Wait for rollout
          kubectl rollout status deployment/wundr-$ENVIRONMENT -n wundr-$ENVIRONMENT
        env:
          ENVIRONMENT: ${{ needs.prepare-deployment.outputs.environment }}
          VERSION: ${{ needs.prepare-deployment.outputs.version }}
          IMAGE: ghcr.io/${{ github.repository }}:${{ needs.prepare-deployment.outputs.version }}

  update-database:
    name: Update Database
    runs-on: ubuntu-latest
    needs: [prepare-deployment, deploy-infrastructure]
    if: needs.prepare-deployment.outputs.rollback == 'false'
    environment:
      name: ${{ needs.prepare-deployment.outputs.environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Run database migrations
        run: |
          # Add database migration logic here
          echo "Running database migrations for ${{ needs.prepare-deployment.outputs.environment }}"

          # Example with Prisma
          # npx prisma migrate deploy

          # Example with custom migration script
          # node scripts/migrate.js
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          NODE_ENV: ${{ needs.prepare-deployment.outputs.environment }}

  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: [prepare-deployment, deploy-infrastructure, update-database]
    if: always() && needs.deploy-infrastructure.result == 'success' && github.event.inputs.skip_health_check != 'true'
    steps:
      - name: Wait for deployment
        run: sleep 60

      - name: Health check
        id: health
        run: |
          URL="${{ needs.prepare-deployment.outputs.deploy-url }}"
          MAX_ATTEMPTS=10
          WAIT_TIME=30

          echo "Checking health of $URL"

          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt $i/$MAX_ATTEMPTS"

            if curl -f -s "$URL/health" > /dev/null; then
              echo "✅ Health check passed"
              echo "healthy=true" >> $GITHUB_OUTPUT
              exit 0
            fi

            if [[ $i -lt $MAX_ATTEMPTS ]]; then
              echo "Health check failed, waiting ${WAIT_TIME}s..."
              sleep $WAIT_TIME
            fi
          done

          echo "❌ Health check failed after $MAX_ATTEMPTS attempts"
          echo "healthy=false" >> $GITHUB_OUTPUT
          exit 1

      - name: Performance check
        if: steps.health.outputs.healthy == 'true'
        run: |
          URL="${{ needs.prepare-deployment.outputs.deploy-url }}"

          echo "Running performance check on $URL"

          # Simple response time check
          RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' "$URL")

          echo "Response time: ${RESPONSE_TIME}s"

          # Fail if response time > 5 seconds
          if (( $(echo "$RESPONSE_TIME > 5" | bc -l) )); then
            echo "❌ Response time too slow: ${RESPONSE_TIME}s"
            exit 1
          fi

          echo "✅ Performance check passed"

      - name: API functionality test
        if: steps.health.outputs.healthy == 'true'
        run: |
          URL="${{ needs.prepare-deployment.outputs.deploy-url }}"

          # Test key API endpoints
          ENDPOINTS=(
            "/api/health"
            "/api/version"
            "/api/analysis/scan"
          )

          for endpoint in "${ENDPOINTS[@]}"; do
            echo "Testing $URL$endpoint"

            STATUS=$(curl -s -o /dev/null -w '%{http_code}' "$URL$endpoint")

            if [[ $STATUS -ge 200 && $STATUS -lt 400 ]]; then
              echo "✅ $endpoint: $STATUS"
            else
              echo "❌ $endpoint: $STATUS"
              exit 1
            fi
          done

  smoke-tests:
    name: Smoke Tests
    runs-on: ubuntu-latest
    needs: [prepare-deployment, health-check]
    if: always() && needs.health-check.result == 'success'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install test dependencies
        run: |
          npm install -g playwright
          npx playwright install

      - name: Run smoke tests
        run: |
          # Run critical user journey tests
          URL="${{ needs.prepare-deployment.outputs.deploy-url }}"

          npx playwright test \
            --config=playwright.smoke.config.js \
            --baseURL="$URL" \
            --reporter=github
        env:
          PLAYWRIGHT_BASE_URL: ${{ needs.prepare-deployment.outputs.deploy-url }}

      - name: Upload smoke test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-test-results-${{ needs.prepare-deployment.outputs.environment }}
          path: test-results/
          retention-days: 7

  rollback-deployment:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    needs: [prepare-deployment, health-check, smoke-tests]
    if: always() && (needs.health-check.result == 'failure' || needs.smoke-tests.result == 'failure' || needs.prepare-deployment.outputs.rollback == 'true')
    environment:
      name: ${{ needs.prepare-deployment.outputs.environment }}
    steps:
      - name: Rollback AWS ECS
        if: secrets.AWS_ACCESS_KEY_ID
        run: |
          aws ecs update-service \
            --cluster "wundr-${{ needs.prepare-deployment.outputs.environment }}" \
            --service "wundr-${{ needs.prepare-deployment.outputs.environment }}" \
            --task-definition "wundr-${{ needs.prepare-deployment.outputs.environment }}:previous"

      - name: Rollback Kubernetes
        if: secrets.KUBE_CONFIG
        run: |
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

          kubectl rollout undo deployment/wundr-${{ needs.prepare-deployment.outputs.environment }} \
            -n wundr-${{ needs.prepare-deployment.outputs.environment }}

      - name: Create rollback issue
        uses: actions/github-script@v7
        with:
          script: |
            const environment = '${{ needs.prepare-deployment.outputs.environment }}';
            const version = '${{ needs.prepare-deployment.outputs.version }}';

            const title = `🚨 Deployment rollback: ${environment} (${version})`;

            const body = `## 🚨 Deployment Rollback Initiated

            **Environment:** ${environment}
            **Version:** ${version}
            **Time:** ${new Date().toISOString()}

            ### ❌ Failure Reasons

            - **Health Check:** ${{ needs.health-check.result }}
            - **Smoke Tests:** ${{ needs.smoke-tests.result }}
            - **Manual Rollback:** ${{ needs.prepare-deployment.outputs.rollback }}

            ### 🔄 Rollback Actions

            Automatic rollback has been initiated for all deployment targets.

            ### 🔍 Investigation

            Please review the deployment logs and resolve the issues before attempting another deployment.

            **Workflow:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            `;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['deployment', 'rollback', 'urgent']
            });

  deployment-status:
    name: Deployment Status
    runs-on: ubuntu-latest
    needs:
      [
        prepare-deployment,
        deploy-infrastructure,
        health-check,
        smoke-tests,
        rollback-deployment,
      ]
    if: always()
    steps:
      - name: Update deployment status
        run: |
          ENVIRONMENT="${{ needs.prepare-deployment.outputs.environment }}"
          VERSION="${{ needs.prepare-deployment.outputs.version }}"
          URL="${{ needs.prepare-deployment.outputs.deploy-url }}"

          if [[ "${{ needs.rollback-deployment.result }}" == "success" ]]; then
            STATUS="🔄 ROLLED BACK"
            COLOR="warning"
          elif [[ "${{ needs.smoke-tests.result }}" == "success" ]]; then
            STATUS="✅ SUCCESS"
            COLOR="success"
          elif [[ "${{ needs.deploy-infrastructure.result }}" == "success" ]]; then
            STATUS="⚠️ DEPLOYED (TESTS FAILED)"
            COLOR="warning"
          else
            STATUS="❌ FAILED"
            COLOR="failure"
          fi

          echo "## 🚀 Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | $ENVIRONMENT |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | $VERSION |" >> $GITHUB_STEP_SUMMARY
          echo "| URL | $URL |" >> $GITHUB_STEP_SUMMARY
          echo "| Status | $STATUS |" >> $GITHUB_STEP_SUMMARY
          echo "| Infrastructure | ${{ needs.deploy-infrastructure.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Health Check | ${{ needs.health-check.result || 'skipped' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Smoke Tests | ${{ needs.smoke-tests.result || 'skipped' }} |" >> $GITHUB_STEP_SUMMARY

      - name: Send notification
        if: secrets.SLACK_WEBHOOK_URL
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: "#deployments"
          text: |
            🚀 *Deployment to ${{ needs.prepare-deployment.outputs.environment }}*

            *Version:* ${{ needs.prepare-deployment.outputs.version }}
            *URL:* ${{ needs.prepare-deployment.outputs.deploy-url }}
            *Status:* ${{ (needs.rollback-deployment.result == 'success' && '🔄 ROLLED BACK') || (needs.smoke-tests.result == 'success' && '✅ SUCCESS') || (needs.deploy-infrastructure.result == 'success' && '⚠️ PARTIAL') || '❌ FAILED' }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
